filter {
     if "ICAT" in [tags] {
      if [message] =~ /environment variable set/ {drop { }}
      if [message] =~ /Authenticated/ {drop { }}
    
      grok {
            break_on_match => true
            match => { "message" => "%{SYSLOGTIMESTAMP:timestamp}\spid:%{POSINT:pid}\s%{LOGLEVEL:level}:\s+%{GREEDYDATA:log_message}" }
            match => { "message" => "%{SYSLOGTIMESTAMP:timestamp}\spid:%{POSINT:pid}\s%{DATA:level}:\s+%{GREEDYDATA:log_message}" }
            match => { "message" => "^remote addresses: %{IP:serverip} %{LOGLEVEL:level}: %{DATA:errormsg} %{NUMBER:errorcode} for id %{NUMBER:pid}\nremote addresses: %{IP} %{LOGLEVEL:level2}: Rule exec for \[\n%{SPACE}%{JAVALOGMESSAGE:irods-rule}\n%{SPACE}" }
#ToDo:            match => { "message" => "^remote addresses: %{IP:serverip} %{LOGLEVEL:level}: %{GREEDYDATA:errmsg}%{SPACE}%{JAVALOGMESSAGE:irods-rule}%{SPACE}%{GREEDYDATA}%{SPACE}%{GREEDYDATA}%{SPACE}%{JAVALOGMESSAGE}%{SPACE}}%{SPACE}failed\." }
      }
     
      mutate {
        add_field => { "logtrail" => "irods" }
      }
      
      # Get client IPs
      if [log_message] =~ /started/ {
                grok {
                      match => { "log_message" => "Agent\sprocess\s%{POSINT:pid}\sstarted\sfor\spuser=%{HTTPDUSER:puser}\sand\scuser=%{HTTPDUSER:cuser}\sfrom\s%{IPV4:clientip}" }
                }
        }
    
      # GeoIP
      if [clientip] {
              geoip {
                source => "clientip"
                target => "geoip"
                database => "/etc/logstash/GeoLite2-City.mmdb"
                add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
                add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
                add_tag => ["geoip"]
#                remove_field => [ "[geoip][longitude]", "[geoip][latitude]" ] # Should these be removed (cleaner) or not (atomic info)
              }
    
              mutate {
                convert => [ "[geoip][coordinates]", "float" ]
              }
       }
       
       
       
       
       # Year is not present in the log date format, getting it from the filename
        grok {
              match => { "source" => "%{YEAR:log_year}" }
        }
        
        
        if [timestamp]{
            mutate {
               replace => [ "timestamp", "%{timestamp} %{log_year}" ]
               remove_field => "log_year"
            }
            date { 
              timezone => "Europe/Amsterdam"
              match => [ "timestamp", "MMM dd HH:mm:ss yyyy", "MMM  d HH:mm:ss yyyy" ]
              remove_field => [ "timestamp" ]       # cleanup, data is available in @timestamp
            }
       }
     }
}
